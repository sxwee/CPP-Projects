# 事务处理线程池

事务处理线程池中使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。

线程池主要特性：

- 同步I/O模拟Proactor。
- 半同步/半反应堆。

## 事务处理模式

### Reactor

Reactor多用于同步I/O，其中心思想是将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程/进程阻塞在多路复用器上。一旦有I/O事件到来，多路复用器返回并将实现注册的I/O事件分发到对应的处理器上。

### Proactor

Proactor多用于异步I/O，主线程和内核负责处理**读写数据、接受新连接**等I/O操作，工作线程**仅负责业务逻辑**，如处理客户请求。

> 由于Linux下异步I/O不成熟，实际中使用较少，在本项目中采用同步I/O模拟实现Proactor模式。

## 同步I/O模拟Proactor

**同步I/O的工作流程**（`epoll_wait`为例）：

- 主线程往`epoll`内核表注册`socket`上的可读写事件。
- 主线程调用`epoll_wait`等待`socket`上有数据可读。
- 当`socket`上有数据可读时，`epoll_wait`通知主线程，主线程从`socket`中循环读取数据，直至没有更多数据可读。然后主线程将读取的数据封装成一个请求对象插入到请求队列。
- 当请求队列不为空时，线程池中阻塞的工作线程会被唤醒，然后去请求队列获取请求对象并处理，然后往`epoll`内核注册该`socket`上的写事件。
- 主线程调用`epoll_write`等待`socket`可写。
- 当`socket`上有数据可写会通知主线程，主线程往`socket`上写入服务器工作线程处理的结果。

## 半同步/半反应堆

半同步/半反应堆是一种并发编程模型，用于处理并发任务和I/O操作。它结合了同步模型和异步模型的特点，能够有效地处理大量的并发连接。

在半同步/半反应堆模型中，系统主要由两部分组成：

- **同步线程池**：包含若干个同步线程，负责处理客户逻辑。
- **反应堆**：负责处理I/O事件和并发连接。它通常采用异步的方式，使用事件驱动机制来监视和处理文件描述符上的事件。当有事件就绪时，反应堆会触发相应的回调函数进行处理。

**半同步/半反应堆工作流程（以Proactor模式为例）**：

- 主线程充当异步线程，负责监听所有`socket`上的事件。
- 若有新请求到来，主线程接收之以得到新的连接`socket`，然后往`epoll`内核事件表中注册该`socket`上的读写事件。
- 如果连接`socket`上有读写事件发生，主线程从`socket`上接收数据，并将数据封装成请求对象插入到请求队列中。
- 当有任务到来时，阻塞的工作线程会被唤醒然后通过竞争获得任务的接管权。

