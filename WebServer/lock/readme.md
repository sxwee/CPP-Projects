# 线程同步机制类

本节实现了用于进行线程同步的**互斥量**、**条件变量**和**信号量**。

在原有API的基础上，本项目采用**RAII (Resource Acquistion is Initalization)**的思想用类对原始的互斥量、条件变量和信号量进行了封装，使得资源或状态与对象的声明周期绑定。

## 互斥量

互斥量`pthread_mutex_t m_mutex`可以保证**同一时刻仅有一个线程可以访问临界区代码**。

互斥量包含两种状态：

- 已锁定
- 未锁定

任何时刻只允许一个线程锁定该互斥量，试图对已经锁定的互斥量加锁会造成阻塞。

项目中用到的互斥量相关的API包括：

```
pthread_mutex_init: 互斥量的初始化
pthread_mutex_destroy: 互斥量的销毁
pthread_mutex_lock: 对互斥量加锁, 如果一个线程加锁了其他线程只能解锁
pthread_mutex_unlock: 对互斥量进行解锁
```

------

## 条件变量

条件变量`pthread_cond_t m_cond`用于**解决线程等待和唤醒问题**的一种机制。

条件变量提供了一个线程等待的机制，当某个条件不满足时，线程可以进入等待状态，并释放所占有的锁。而其他线程可以在条件满足时通过唤醒操作来通知等待的线程继续执行。

条件变量通常与互斥量一起使用。通过结合互斥锁和条件变量，可以实现复杂的线程同步和通信机制。主要包括以下三个操作：

- **`wait`**: 线程程在满足某个条件之前，调用条件变量的等待操作，进入等待状态，并释放所持有的互斥锁。这样其他线程就可以获取该互斥锁并继续执行。
- **`notify`**: 线程在某个条件满足时，调用条件变量的通知操作，唤醒等待在该条件变量上的**一个线程**。被唤醒的线程将重新获取互斥锁，并继续执行。
- **`broadcast`**: 与`notify`类似，但广播操作会唤醒等待在该条件变量上的所有线程。

项目中用到的条件变量相关的API包括：

```
pthread_cond_init: 条件变量的初始化
pthread_cond_destroy: 销毁条件变量
pthread_cond_timedwait:
	**首先会自动释放互斥锁，然后将当前线程设置为等待状态，等待条件变量的唤醒
	**若在等待过程中下列情况发生函数将返回
		**条件满足
		**超时(设置的等待时间已到但条件仍未满足)
		**收到信号
	**在上述情况下, 函数会重新获得互斥锁，并返回0。
pthread_cond_wait: 
	**当调用该函数时，它会自动释放互斥锁，并将当前线程置于睡眠状态，等待条件变量的唤醒。
	**一旦有其他线程调用pthread_cond_signal或pthread_cond_broadcast函数唤醒等待的线程，该线程将被唤醒并重新获取互斥锁。
	**线程重新获取互斥锁后，可以继续执行后续的代码
pthread_cond_signal: 即唤醒单个等待的线程
pthread_cond_broadcast: 唤醒所有等待的线程
```

------

## 信号量

信号量是一种**特殊的计数器**，用于控制对共享资源的访问。

信号量维护了一个整型变量和一个等待队列，用于记录可用资源的数量和等待获取资源的线程或进程。它提供两个基本操作：

- **P（Wait）**：当线程或进程希望使用一个资源时，它需要执行P操作。如果信号量的计数器大于0，则可以继续执行，同时计数器减1。如果计数器为0，则线程或进程将被阻塞，加入到等待队列中，直到有其他线程或进程释放资源。
- **V（Signal）**：当线程或进程释放一个资源时，它需要执行V操作。V操作将计数器加1，并且如果有等待队列中的线程或进程，会唤醒其中的一个，使其继续执行。

信号量的主要作用如下：

- **互斥**：通过二元信号量（**计数器初始为1**），实现对共享资源的互斥访问。只允许一个线程或进程使用资源，其他线程或进程需要等待。
- **同步**：通过多元信号量（**计数器大于1**），实现线程或进程间的同步。控制并发线程或进程的执行顺序，确保在特定时机只有指定数量的线程或进程能够继续执行。

项目中用到的信号量相关的API包括：

```
sem_init: 初始化信号量
sem_destroy: 销毁信号量
sem_wait: 对信号量加锁, 调用一次信号量减1, 如果值为0则阻塞。
sem_post: 对信号量解锁, 调用一次对信号量加1
```

